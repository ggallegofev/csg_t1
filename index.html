<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>REF Question Library — Cheatsheet builder</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 1rem 1.5rem;
      background: #fafafa;
      color: #1a1a1a;
    }
    h1 { margin: 0 0 0.5rem; font-size: 1.5rem; font-weight: 600; }
    .subtitle { color: #555; font-size: 0.9rem; margin-bottom: 1rem; }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }
    .toolbar label { display: flex; align-items: center; gap: 0.35rem; }
    select {
      padding: 0.4rem 0.6rem;
      font-size: 0.9rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #fff;
    }
    button {
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: #1a1a1a;
      color: #fff;
    }
    button:hover { background: #333; }
    button.secondary { background: #666; }
    button.secondary:hover { background: #555; }
    .table-wrap {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      overflow: auto;
      max-height: 70vh;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }
    th, td { padding: 0.5rem 0.75rem; text-align: left; border-bottom: 1px solid #eee; }
    th {
      position: sticky;
      top: 0;
      background: #fafafa;
      font-weight: 600;
      white-space: nowrap;
    }
    th.sortable { cursor: pointer; user-select: none; }
    th.sortable:hover { background: #f0f0f0; }
    tr:hover { background: #f9f9f9; }
    td.question { max-width: 320px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    td.question[title] { cursor: help; }
    .loading, .error { padding: 2rem; text-align: center; color: #666; }
    .error { color: #c00; }
    .selected-count { font-size: 0.85rem; color: #555; }
    tr.detail-row td { background: #f9f9f9; padding: 0.75rem 1rem; border-bottom: 1px solid #eee; vertical-align: top; }
    .detail-content { font-size: 0.8rem; display: grid; grid-template-columns: auto 1fr; gap: 0.25rem 1rem; max-width: 640px; }
    .detail-content dt { color: #555; }
    .detail-content dd { margin: 0; }
    .detail-toggle { cursor: pointer; color: #666; text-decoration: underline; }
    .detail-toggle:hover { color: #1a1a1a; }
    .fill-refs-section { margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid rgba(0,0,0,0.1); }
    .fill-refs-section h2 { margin: 0 0 0.5rem; font-size: 1.2rem; font-weight: 600; }
    .fill-refs-section .fill-refs-desc { color: #555; font-size: 0.9rem; margin-bottom: 1rem; max-width: 560px; }
    .fill-refs-section .fill-refs-toolbar { display: flex; flex-wrap: wrap; align-items: center; gap: 0.75rem; margin-bottom: 1rem; }
    .fill-refs-section .fill-refs-toolbar input[type="file"] { font-size: 0.9rem; }
    .fill-refs-results { background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); overflow: auto; max-height: 40vh; margin-top: 1rem; }
    .fill-refs-results table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
    .fill-refs-results th, .fill-refs-results td { padding: 0.5rem 0.75rem; text-align: left; border-bottom: 1px solid #eee; }
    .fill-refs-results th { background: #fafafa; font-weight: 600; }
    .fill-refs-results td.question-snippet { max-width: 320px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .fill-refs-results .no-match { color: #999; }
    .fill-refs-section .error-msg { color: #c00; font-size: 0.9rem; margin-top: 0.5rem; }
  </style>
</head>
<body>
  <h1>REF Question Library</h1>
  <p class="subtitle">Select REFs and download a cheatsheet CSV for your form generator.</p>

  <section class="fill-refs-section" id="fillRefsSection">
    <h2>Fill missing REFs from cheatsheet</h2>
    <p class="fill-refs-desc">Upload a CSV with question wordings but missing REFs; we'll match each row to the library and give you a REF list to paste into your sheet.</p>
    <div class="fill-refs-toolbar">
      <label>
        <span>CSV file</span>
        <input type="file" id="fillRefsFile" accept=".csv">
      </label>
      <button type="button" class="secondary" id="copyRefsBtn" disabled>Copy REFs</button>
    </div>
    <div id="fillRefsError" class="error-msg" hidden></div>
    <div id="fillRefsResults" class="fill-refs-results" hidden>
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Question (snippet)</th>
            <th>Matched REF</th>
          </tr>
        </thead>
        <tbody id="fillRefsTbody"></tbody>
      </table>
    </div>
  </section>

  <div class="toolbar">
    <label>
      <span>Language</span>
      <select id="lang">
        <option value="">English</option>
        <option value="fr">French</option>
        <option value="es">Spanish</option>
      </select>
    </label>
    <label>
      <span>Search</span>
      <input type="text" id="search" placeholder="Search refs…" style="padding:0.4rem 0.6rem;font-size:0.9rem;border:1px solid #ccc;border-radius:4px;min-width:140px;">
    </label>
    <label>
      <span>Scalability</span>
      <select id="filterScalability">
        <option value="">All</option>
        <option value="Standard">Standard</option>
        <option value="Custom">Custom</option>
      </select>
    </label>
    <label>
      <span>Group</span>
      <select id="filterGroup">
        <option value="">All</option>
        <option value="Plan">Plan</option>
        <option value="User">User</option>
        <option value="Ancillary">Ancillary</option>
      </select>
    </label>
    <button type="button" class="secondary" id="commonSet">Common set</button>
    <button type="button" class="secondary" id="selectAll">Select all</button>
    <button type="button" class="secondary" id="clearAll">Clear</button>
    <button type="button" id="download">Download cheatsheet</button>
    <span class="selected-count" id="selectedCount">0 selected</span>
  </div>

  <div class="table-wrap">
    <div class="loading" id="loading">Loading REFs…</div>
    <table id="table" hidden>
      <thead>
        <tr>
          <th><input type="checkbox" id="toggleAll" title="Toggle all"></th>
          <th class="sortable" data-sort="scalability">Scalability</th>
          <th class="sortable" data-sort="group">Group</th>
          <th class="sortable" data-sort="ref">ref</th>
          <th class="sortable" data-sort="question">question</th>
          <th class="sortable" data-sort="type">type</th>
          <th></th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>

  <script>
    const CHEATSHEET_HEADERS = [
      'Scalability', 'Group', 'Comment', 'ref', 'question', 'question description',
      'type', 'scale', 'start_at_one', 'left_label', 'center_label', 'right_label',
      'allow_multiple_selection', 'allow_other_choice', 'choices (separated by ";")', 'randomized'
    ];

    function normalizeQuestion(text) {
      if (text == null || text === '') return '';
      return String(text).trim().replace(/\s+/g, ' ').toLowerCase();
    }

    function parseCsv(text) {
      const rows = [];
      let i = 0;
      const len = text.length;
      while (i < len) {
        const row = [];
        while (i < len) {
          if (text[i] === '"') {
            let cell = '';
            i++;
            while (i < len) {
              if (text[i] === '"') {
                i++;
                if (text[i] === '"') { cell += '"'; i++; }
                else break;
              } else { cell += text[i]; i++; }
            }
            row.push(cell);
            if (text[i] === ',') i++;
            else if (text[i] === '\r' || text[i] === '\n' || i >= len) break;
          } else {
            let cell = '';
            while (i < len && text[i] !== ',' && text[i] !== '\r' && text[i] !== '\n') {
              cell += text[i];
              i++;
            }
            row.push(cell.trim());
            if (text[i] === ',') i++;
            else break;
          }
        }
        if (text[i] === '\r') i++;
        if (text[i] === '\n') i++;
        rows.push(row);
      }
      return rows;
    }

    function findColumnIndex(headers, name) {
      const n = normalizeQuestion(name);
      for (let i = 0; i < headers.length; i++) {
        if (normalizeQuestion(headers[i]) === n) return i;
      }
      return -1;
    }

    function escapeCsv(value) {
      if (value === null || value === undefined || value === '') return '';
      const s = String(value);
      if (/[,"\n\r]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
      return s;
    }

    function cellValue(v) {
      if (v === null || v === undefined) return '';
      if (typeof v === 'boolean') return v ? 'TRUE' : 'FALSE';
      return v;
    }

    function getOverrides(ref, lang) {
      if (!lang) return null;
      const t = translations[ref.ref]?.[lang];
      if (!t) return null;
      if (typeof t === 'string') return { question: t };
      return t;
    }

    function refToRow(ref, overrides) {
      const o = overrides || {};
      const q = o.question ?? ref.question ?? '';
      const qd = o.question_description ?? ref.question_description ?? '';
      const left = o.left_label ?? ref.left_label ?? '';
      const center = o.center_label ?? ref.center_label ?? '';
      const right = o.right_label ?? ref.right_label ?? '';
      const choices = o.choices ?? ref.choices ?? '';
      return [
        ref.scalability ?? '',
        ref.group ?? '',
        ref.comment ?? '',
        ref.ref ?? '',
        q,
        qd,
        ref.type ?? '',
        ref.scale ?? '',
        ref.start_at_one === true ? 'TRUE' : ref.start_at_one === false ? 'FALSE' : '',
        left,
        center,
        right,
        ref.allow_multiple_selection === true ? 'TRUE' : ref.allow_multiple_selection === false ? 'FALSE' : '',
        ref.allow_other_choice === true ? 'TRUE' : ref.allow_other_choice === false ? 'FALSE' : '',
        choices,
        ref.randomized === true ? 'TRUE' : ref.randomized === false ? 'FALSE' : ''
      ];
    }

    let refs = [];
    let translations = {};
    let questionLookup = new Map();
    const selectedRefs = new Set();
    let filteredAndSortedRefs = [];
    let searchQuery = '';
    let filterScalability = '';
    let filterGroup = '';
    let sortKey = '';
    let sortDirection = 'asc';
    let expandedRef = null;
    let lastMatchedRefs = [];

    async function loadData() {
      const loading = document.getElementById('loading');
      try {
        const [refsRes, transRes] = await Promise.all([
          fetch('data/refs.json'),
          fetch('data/translations.json').catch(() => null)
        ]);
        if (!refsRes.ok) throw new Error('Failed to load refs.json');
        const refsData = await refsRes.json();
        refs = refsData.refs || [];
        if (transRes && transRes.ok) {
          const transData = await transRes.json();
          translations = transData.translations || {};
        }
      } catch (e) {
        loading.textContent = 'Error: ' + (e.message || 'Could not load data. Serve this folder with a local server (e.g. npx serve .).');
        loading.className = 'error';
        return;
      }
      loading.hidden = true;
      document.getElementById('table').hidden = false;
      buildQuestionLookup();
      applyFiltersAndSort();
      renderTable();
    }

    function buildQuestionLookup() {
      questionLookup = new Map();
      for (const r of refs) {
        const q = (r.question || '').trim();
        if (q) {
          const key = normalizeQuestion(q);
          if (!questionLookup.has(key)) questionLookup.set(key, r.ref);
        }
        const trans = translations[r.ref];
        if (trans && typeof trans === 'object') {
          for (const lang of Object.keys(trans)) {
            const t = trans[lang];
            const qq = typeof t === 'string' ? t : (t && t.question);
            if (qq) {
              const trimmed = String(qq).trim();
              if (trimmed) {
                const key = normalizeQuestion(trimmed);
                if (!questionLookup.has(key)) questionLookup.set(key, r.ref);
              }
            }
          }
        }
      }
    }

    function getWording(ref, lang) {
      const o = getOverrides(ref, lang);
      if (!o) return { q: ref.question, d: ref.question_description };
      return { q: o.question ?? ref.question, d: o.question_description ?? ref.question_description };
    }

    function getSelectedLang() {
      const el = document.getElementById('lang');
      if (!el) return null;
      const v = (el.value || '').trim();
      return v || null;
    }

    function toggleDetail(refId) {
      expandedRef = expandedRef === refId ? null : refId;
      renderTable();
    }

    function formatDetailRow(ref, lang) {
      const o = getOverrides(ref, lang) || {};
      const q = o.question ?? ref.question ?? '';
      const qd = o.question_description ?? ref.question_description ?? '';
      const left = o.left_label ?? ref.left_label ?? '';
      const center = o.center_label ?? ref.center_label ?? '';
      const right = o.right_label ?? ref.right_label ?? '';
      const choices = o.choices ?? ref.choices ?? '';
      const type = ref.type ?? '';
      const scale = ref.scale ?? '';
      const startAtOne = ref.start_at_one === true ? 'TRUE' : ref.start_at_one === false ? 'FALSE' : '';
      const multi = ref.allow_multiple_selection === true ? 'TRUE' : ref.allow_multiple_selection === false ? 'FALSE' : '';
      const other = ref.allow_other_choice === true ? 'TRUE' : ref.allow_other_choice === false ? 'FALSE' : '';
      const rand = ref.randomized === true ? 'TRUE' : ref.randomized === false ? 'FALSE' : '';
      const rows = [
        ['question', q],
        ['question description', qd],
        ['type', type],
        ['scale', scale],
        ['start_at_one', startAtOne],
        ['left_label', left],
        ['center_label', center],
        ['right_label', right],
        ['allow_multiple_selection', multi],
        ['allow_other_choice', other],
        ['choices', choices],
        ['randomized', rand]
      ];
      const cells = rows.map(([k, v]) => '<dt>' + k + '</dt><dd>' + (v == null ? '' : String(v)).replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</dd>').join('');
      return '<dl class="detail-content">' + cells + '</dl>';
    }

    function applyFiltersAndSort() {
      const lang = getSelectedLang();
      const q = (document.getElementById('search')?.value || '').trim().toLowerCase();
      const scaleFilter = (document.getElementById('filterScalability')?.value || '').trim();
      const groupFilter = (document.getElementById('filterGroup')?.value || '').trim();
      searchQuery = q;
      filterScalability = scaleFilter;
      filterGroup = groupFilter;
      let list = refs.filter(ref => {
        if (scaleFilter && ref.scalability !== scaleFilter) return false;
        if (groupFilter && ref.group !== groupFilter) return false;
        if (!q) return true;
        const wording = getWording(ref, lang);
        const question = (wording.q || '').toLowerCase();
        const refId = (ref.ref || '').toLowerCase();
        const scal = (ref.scalability || '').toLowerCase();
        const grp = (ref.group || '').toLowerCase();
        const typ = (ref.type || '').toLowerCase();
        return refId.includes(q) || question.includes(q) || scal.includes(q) || grp.includes(q) || typ.includes(q);
      });
      const key = sortKey;
      const dir = sortDirection === 'asc' ? 1 : -1;
      if (key) {
        list = list.slice().sort((a, b) => {
          let va, vb;
          if (key === 'question') {
            va = (getWording(a, lang).q || '').toLowerCase();
            vb = (getWording(b, lang).q || '').toLowerCase();
          } else {
            va = (a[key] ?? '').toString().toLowerCase();
            vb = (b[key] ?? '').toString().toLowerCase();
          }
          const c = va < vb ? -1 : va > vb ? 1 : 0;
          return c * dir;
        });
      }
      filteredAndSortedRefs = list;
    }

    function renderTable() {
      const lang = getSelectedLang();
      const list = filteredAndSortedRefs.length ? filteredAndSortedRefs : refs.slice();
      const tbody = document.getElementById('tbody');
      const frag = [];
      list.forEach(ref => {
        const id = 'ref-' + ref.ref;
        const wording = getWording(ref, lang);
        const q = (wording.q || '').replace(/"/g, '&quot;').replace(/</g, '&lt;');
        const checked = selectedRefs.has(ref.ref) ? ' checked' : '';
        const detailLabel = expandedRef === ref.ref ? 'Hide details' : 'Details';
        frag.push('<tr data-ref="' + ref.ref + '">' +
          '<td><input type="checkbox" class="ref-cb" id="' + id + '" value="' + ref.ref + '"' + checked + '></td>' +
          '<td>' + (ref.scalability || '') + '</td>' +
          '<td>' + (ref.group || '') + '</td>' +
          '<td>' + (ref.ref || '') + '</td>' +
          '<td class="question" title="' + q + '">' + q + '</td>' +
          '<td>' + (ref.type || '') + '</td>' +
          '<td><span class="detail-toggle" data-ref="' + ref.ref + '">' + detailLabel + '</span></td>' +
        '</tr>');
        if (expandedRef === ref.ref) {
          frag.push('<tr class="detail-row"><td colspan="7">' + formatDetailRow(ref, lang) + '</td></tr>');
        }
      });
      tbody.innerHTML = frag.join('');
      updateCount();
    }

    function getSelectedRefs() {
      return Array.from(selectedRefs);
    }

    function updateCount() {
      const n = selectedRefs.size;
      const list = filteredAndSortedRefs.length ? filteredAndSortedRefs : refs;
      const visibleCount = list.length;
      const visibleSelected = visibleCount && list.every(r => selectedRefs.has(r.ref)) ? visibleCount : 0;
      document.getElementById('selectedCount').textContent = n + ' selected';
      document.getElementById('toggleAll').checked = visibleCount > 0 && visibleSelected === visibleCount;
      document.getElementById('toggleAll').indeterminate = visibleSelected > 0 && visibleSelected < visibleCount;
    }

    function buildCsv(selectedIds, lang) {
      const refByRef = new Map(refs.map(r => [r.ref, r]));
      const rows = [CHEATSHEET_HEADERS.map(escapeCsv).join(',')];
      for (const refId of selectedIds) {
        const ref = refByRef.get(refId);
        if (!ref) continue;
        const overrides = getOverrides(ref, lang);
        const row = refToRow(ref, overrides);
        rows.push(row.map(c => escapeCsv(cellValue(c))).join(','));
      }
      return rows.join('\n');
    }

    function downloadCsv() {
      const selected = Array.from(selectedRefs);
      if (selected.length === 0) {
        alert('Select at least one REF.');
        return;
      }
      const lang = getSelectedLang();
      const csv = buildCsv(selected, lang);
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = lang ? 'cheatsheet-' + lang + '.csv' : 'cheatsheet.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    function processFillRefsCsv(csvText) {
      const rows = parseCsv(csvText);
      if (rows.length === 0) {
        return { error: 'CSV is empty.' };
      }
      const headers = rows[0];
      const dataRows = rows.slice(1);
      const questionCol = findColumnIndex(headers, 'question');
      if (questionCol < 0) {
        return { error: 'No column named "question" found. Use the standard cheatsheet column order or a CSV with a "question" header.' };
      }
      const refCol = findColumnIndex(headers, 'ref');
      const matched = [];
      for (let i = 0; i < dataRows.length; i++) {
        const row = dataRows[i];
        const existingRef = refCol >= 0 && row[refCol] != null ? String(row[refCol]).trim() : '';
        const questionCell = row[questionCol] != null ? String(row[questionCol]) : '';
        const normalized = normalizeQuestion(questionCell);
        let refId = '';
        if (existingRef) {
          refId = existingRef;
        } else if (normalized && questionLookup.has(normalized)) {
          refId = questionLookup.get(normalized);
        }
        matched.push({
          rowIndex: i + 1,
          questionSnippet: questionCell.length > 50 ? questionCell.slice(0, 50) + '…' : questionCell,
          ref: refId
        });
      }
      lastMatchedRefs = matched;
      return { matched, dataRows };
    }

    function renderRefLookupResults() {
      const tbody = document.getElementById('fillRefsTbody');
      const frag = lastMatchedRefs.map(m => {
        const refDisplay = m.ref || '—';
        const cellClass = m.ref ? '' : ' no-match';
        const snippet = (m.questionSnippet || '').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        return '<tr><td>' + m.rowIndex + '</td><td class="question-snippet" title="' + snippet + '">' + snippet + '</td><td class="' + cellClass.trim() + '">' + refDisplay + '</td></tr>';
      });
      tbody.innerHTML = frag.join('');
    }

    function copyRefsToClipboard() {
      const text = lastMatchedRefs.map(m => m.ref || '—').join('\n');
      navigator.clipboard.writeText(text).then(() => {
        const btn = document.getElementById('copyRefsBtn');
        const orig = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(() => { btn.textContent = orig; }, 1500);
      }).catch(() => alert('Could not copy to clipboard.'));
    }

    document.getElementById('fillRefsFile').addEventListener('change', function() {
      const file = this.files && this.files[0];
      const errEl = document.getElementById('fillRefsError');
      const resultsEl = document.getElementById('fillRefsResults');
      const copyBtn = document.getElementById('copyRefsBtn');
      errEl.hidden = true;
      resultsEl.hidden = true;
      copyBtn.disabled = true;
      lastMatchedRefs = [];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        let text;
        try {
          text = reader.result;
          if (typeof text !== 'string') text = new TextDecoder('utf-8').decode(text);
        } catch (e) {
          errEl.textContent = 'Could not read file.';
          errEl.hidden = false;
          return;
        }
        const result = processFillRefsCsv(text);
        if (result.error) {
          errEl.textContent = result.error;
          errEl.hidden = false;
          return;
        }
        if (result.matched && result.matched.length === 0) {
          errEl.textContent = 'No data rows.';
          errEl.hidden = false;
          return;
        }
        renderRefLookupResults();
        resultsEl.hidden = false;
        copyBtn.disabled = false;
      };
      reader.readAsText(file, 'UTF-8');
    });

    document.getElementById('copyRefsBtn').addEventListener('click', copyRefsToClipboard);

    document.getElementById('tbody').addEventListener('change', e => {
      if (e.target.classList.contains('ref-cb')) {
        const refId = e.target.value;
        if (e.target.checked) selectedRefs.add(refId);
        else selectedRefs.delete(refId);
        updateCount();
      }
    });

    document.getElementById('tbody').addEventListener('click', e => {
      if (e.target.classList.contains('detail-toggle')) {
        const refId = e.target.getAttribute('data-ref');
        if (refId) toggleDetail(refId);
      }
    });

    document.getElementById('toggleAll').addEventListener('change', function() {
      const list = filteredAndSortedRefs.length ? filteredAndSortedRefs : refs;
      list.forEach(r => this.checked ? selectedRefs.add(r.ref) : selectedRefs.delete(r.ref));
      renderTable();
    });

    document.getElementById('selectAll').addEventListener('click', () => {
      const list = filteredAndSortedRefs.length ? filteredAndSortedRefs : refs;
      list.forEach(r => selectedRefs.add(r.ref));
      renderTable();
    });

    document.getElementById('clearAll').addEventListener('click', () => {
      selectedRefs.clear();
      renderTable();
    });

    const COMMON_SET_REFS = ['plan_nps', 'age', 'company', 'discovery', 'improvement_ideas', 'favorite_element', 'rating_vfm', 'rating_venue'];
    document.getElementById('commonSet').addEventListener('click', () => {
      COMMON_SET_REFS.forEach(id => selectedRefs.add(id));
      renderTable();
    });

    document.getElementById('download').addEventListener('click', downloadCsv);

    document.getElementById('lang').addEventListener('change', () => {
      applyFiltersAndSort();
      renderTable();
    });

    document.getElementById('search').addEventListener('input', () => {
      applyFiltersAndSort();
      renderTable();
    });
    document.getElementById('filterScalability').addEventListener('change', () => {
      applyFiltersAndSort();
      renderTable();
    });
    document.getElementById('filterGroup').addEventListener('change', () => {
      applyFiltersAndSort();
      renderTable();
    });

    document.querySelectorAll('th.sortable').forEach(th => {
      th.addEventListener('click', () => {
        const key = th.getAttribute('data-sort');
        if (!key) return;
        if (sortKey === key) sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
        else { sortKey = key; sortDirection = 'asc'; }
        applyFiltersAndSort();
        renderTable();
      });
    });

    loadData();
  </script>
</body>
</html>
